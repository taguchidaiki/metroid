6/6

タグ　継承のオーバーライド　オーバーライド　オーバーロード
-------------------------------------------------------------------------

コンソール使用時設定変更
○○のプロパティ　→　構成をアクティブ　→　C/C++のプリコンパイル済みヘッダー　
→プリコンパイル済みヘッダーを使用しないに変更

これでわざわざすべてのクラスにあるヘッダーを読み込まなくて済む

--------------------------------------------------------------------------
オーバーライドの仕組み
継承は基底クラスの上に派生クラスが上乗せされている状態
それぞれに同じ関数（引数、返り値同じ）があるとして、その同じ関数を呼んだとき
まずはその実体のクラスを探し始める

例
派生クラスで実体を生成したとき、まずは派生クラスを見て関数を探し始める
見つけられなかったときは階層を一段階下げて関数を探し始める
この場合は派生クラスにない場合、基底クラスを探し始める

基本的には同じ階層を探してなかったら階層を下げるイメージ
ただし、下の階層から上の階層を見ることはない

--------------------------------------------------------------------------
継承のオーバーライド
継承した派生クラスの実体は基底クラスの型で生成することはできる
ただし、オーバーライドによって同じ関数があったとしてもこの場合は基底クラスの関数しか見ない
すなわち、派生側の関数は見ることができないのである

しかし、基底クラスのオーバーライドした関数にvirtual修飾子を付けることでその問題は解決できる
基底クラスにvirtual修飾子を使うと、オーバーライドした関数を呼ぶとき基底クラスではなく派生クラスの関数が
優先して呼ばれることになる
これを仮想関数と呼ぶ

これに＋して純粋仮想関数と呼ばれるものも存在する
作り方は基底クラスに作った仮想関数に　= 0を加えるだけである
これによって関数のポインタがないよって状態になるから上の階層のオーバーライド関数を必ず見に行くようになる
ただし、注意事項として上の階層（継承側のクラス）に必ずオーバーライドした関数がある必要がある
なかったらコンパイル通らないからすぐわかるよ

ちなみにvirtual修飾子はデストラクタによく使われていることがある
なぜかは、デストラクタが呼ばれるときは基底と派生のデストラクタが両方呼ばれるのだが正直派生の生成をしているのであれば
基底のデストラクタは呼ぶ必要性がない
なのでデストラクタ内で特定の処理をしていない限り、基底側のデストラクタにはvirtual修飾子をつけるといいそうだ
VisualStudioではクラスウィザードで新しくクラスを作るときに[仮想デストラクタ]にチェックを入れることでわざわざ自作で作る必要がなくなります
-------------------------------------------------------------------------------

参考サイト
１週間で身につくC＋＋言語