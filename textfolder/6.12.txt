6/12

------------------------------------------------------------------------------------------
オブジェクトの描画位置などはその位置をよく使う中心に合わせたほうがいい
例：2次元の重力ありのゲームならその足元に中心の位置情報があったほうが都合がいいなど

------------------------------------------------------------------------------------------
#includeは他から参照される回数が多いものほど優先して上に書いてたりするといい
その他のやり方はその会社の規約にのっとって#includeする順番を考える

-------------------------------------------------------------------------------------------
コンストラクタのオーバーロードで初期化をする際は初期化をする順番は継承先で合わせるようにしたほうが
インスタンス時に可読性が上がる

--------------------------------------------------------------------------------------------
C++11になってから初期化リスト{}が使えるようになった
使い方：Vector2 vec(0,0) == Vector2 vec{0,0}
初期化リストは{}内の要素に対して上から順番に要素の初期化をしているだけで別に引数付きコンストラクタが呼ばれているわけではない
引数付きコンストラクタでの初期化と挙動は同じだが、中の動き方が違うのでこの辺は勘違いしてはいけない

--------------------------------------------------------------------------------------------
重くなる原因の一つ
メモリの再配置
例:１０個の要素の確保を行った時、追加で１個の要素を増やしたいがメモリの空きが別の場所にしかない場合、内部では
１１個のメモリを改めて確保したのち、１０個の要素を持つメモリをコピーして１個の要素を追加する
書いているだけでも処理が多くて重くなりそうである

そのために意識しなければならないのはメモリ効率である

---------------------------------------------------------------------------------------------
STL(standard template library)	便利なやつらのライブラリー群

固定長配列のSTL		std::array
可変長配列のSTL		std::vector
一つの要素を生成したときのメモリのサイズの差はarray < vector
vectorは可変長の分arrayより多少多くメモリを確保する？
小さいサイズのメモリ確保ならばarrayのほうに分がある

----------------------------------------------------------------------------------------------
arrayの使い方
#include <array>

宣言　std::array<要素の型,　配列のサイズ> 変数名

----------------------------------------------------------------------------------------------
vectorの使い方
#include<vector>

宣言　std::vector<要素の型> 変数名

resize(要素数)		vectorの変数のsizeを任意の値に変更する
resizeを使うときはあらかじめ使用量の最大値でresizeをして、そのあとに実際に使用分でresizeをし直しておくと
速度的には変わらない
*一回大きい領域を取って、改めて小さい領域を取りなおしたときsizeの値は変更されるがcapacityは変更がかからない
ので実際に使用しているメモリ消費量は変わらないことに注意

reserve(要素数）	vectorの予約領域（capacity）を確保する

----------------------------------------------------------------------------------------------
listの使い方
#include<list>

宣言　std::list<要素の型> 変数名

push_back(要素）	listの変数の後ろに要素を追加する
push_front(要素）	listの変数の前に要素を追加する

back,frontの使い方の例
背景、敵、プレイヤーの描画をする際に描画は後優先なので奥に描画したいものをlistの前に、手前に描画したいものをlistの後ろに追加するとか

begin()			listの先頭にアクセスする

listは構造上、メモリが連続で並んでいるわけではなく要素のポインタとその前の要素へアクセスするbegin()と最後の要素であるend()を持っていて
それがメモリ上に散らばって配置されているからvectorと違ってメモリの再配置が起きない
ただし、メモリの解放を行うとき先にlistを削除してしまうと実体へのポインタを失うことになるので作ってしまった実態に永遠にアクセスすることが
できなくなりメモリーリークが起きてしまう
だから、メモリの解放を行うときはまず実体の削除を行ってからリストつなぎなおしをしてあげないと危ないことになる

-----------------------------------------------------------------------------------------------
